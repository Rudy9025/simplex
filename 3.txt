To implement a dynamic and reusable auditing system without duplicating methods in every component, you can use a more centralized approach. Here’s how you can achieve this:

⸻

Frontend (Dynamic Auditing)

1. Use Angular Router Events to Track Navigation

Listen to router events to capture which component the user navigates to dynamically.

2. Create a Global Event Emitter for User Actions

Instead of adding methods like onEdit, onDelete in every component, centralize the auditing logic in a shared service and trigger it dynamically using Angular’s event emitter.

⸻

Implementation

1. Create a Central AuditService

This service will capture both navigation and user actions dynamically.

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Router, NavigationEnd } from '@angular/router';
import { filter } from 'rxjs/operators';

@Injectable({
  providedIn: 'root',
})
export class AuditService {
  private auditUrl = 'http://localhost:8080/api/audit';

  constructor(private http: HttpClient, private router: Router) {
    // Capture navigation events
    this.router.events
      .pipe(filter((event) => event instanceof NavigationEnd))
      .subscribe((event: any) => {
        const section = event.urlAfterRedirects.split('/').pop();
        this.logNavigation(section);
      });
  }

  logAction(action: string, notes: string) {
    const username = localStorage.getItem('username') || 'Guest';
    const section = this.router.url.split('/').pop(); // Dynamically fetch the current section

    const payload = {
      username: username,
      section: section || 'Unknown Section',
      action: action,
      notes: notes,
      timestamp: new Date(),
    };

    this.http.post(this.auditUrl, payload).subscribe({
      next: (response) => console.log('Audit logged:', response),
      error: (error) => console.error('Error logging audit:', error),
    });
  }

  private logNavigation(section: string) {
    const username = localStorage.getItem('username') || 'Guest';
    const payload = {
      username: username,
      section: section || 'Unknown Section',
      action: 'Navigation',
      notes: `Navigated to ${section}`,
      timestamp: new Date(),
    };

    this.http.post(this.auditUrl, payload).subscribe({
      next: (response) => console.log('Navigation logged:', response),
      error: (error) => console.error('Error logging navigation:', error),
    });
  }
}


⸻

2. Use AuditService in Your Components

Now, you don’t need to write separate methods for auditing in every component. Instead, use the service dynamically:

import { Component } from '@angular/core';
import { AuditService } from '../services/audit.service';

@Component({
  selector: 'app-manage-company',
  templateUrl: './manage-company.component.html',
  styleUrls: ['./manage-company.component.css'],
})
export class ManageCompanyComponent {
  constructor(private auditService: AuditService) {}

  handleAction(action: string, notes: string) {
    this.auditService.logAction(action, notes);
  }
}


⸻

3. Update HTML with Dynamic Actions

You can pass dynamic actions to the centralized service.

<main>
  <div class="container">
    <div class="tools">
      <img
        src="assets/icons/edit.png"
        alt="edit"
        title="edit"
        (click)="handleAction('Edit', 'Company edited')"
      />
      <img
        src="assets/icons/delete.png"
        alt="Delete"
        title="Delete"
        (click)="handleAction('Delete', 'Company deleted')"
      />
      <img
        src="assets/icons/update.png"
        alt="Update"
        title="Update"
        (click)="handleAction('Update', 'Company updated')"
      />
    </div>
  </div>
</main>


⸻

Backend (Dynamic Support)

1. Enhance Audit Controller

The backend already supports a generic logging mechanism. Ensure it dynamically handles all components and operations.

@RestController
@RequestMapping("/api/audit")
public class AuditController {

    @Autowired
    private AuditLogRepository auditLogRepository;

    @PostMapping
    public ResponseEntity<String> logAction(@RequestBody AuditLog auditLog) {
        auditLog.setTimestamp(LocalDateTime.now());
        auditLogRepository.save(auditLog);
        return ResponseEntity.status(HttpStatus.CREATED).body("Audit logged successfully.");
    }
}

2. Add an Enum or Constant for Sections (Optional)

If you want stricter control over section names, maintain a list of valid section names in the backend.

⸻

Database (No Change)

The audit_rud table already supports a dynamic structure:

CREATE TABLE audit_rud (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR2(255),
    section VARCHAR2(255),
    action VARCHAR2(255),
    notes VARCHAR2(1000),
    timestamp TIMESTAMP
);


⸻

Dynamic Auditing Across the Application

Now, the system is set up to:
	1.	Automatically log navigation (via Angular Router events).
	2.	Dynamically log actions using a centralized AuditService.
	3.	Easily scale to future components and actions without additional duplication.

Let me know if you’d like further enhancements!